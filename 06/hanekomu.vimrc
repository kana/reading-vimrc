set backspace=indent,eol,start
set nocompatible
"
behave xterm
"       mouse and selection should work as in xterm
set incsearch
"    incrementally shows matches as we type
set visualbell t_vb=
"    damn beeps again
set title
"    show filename in window title
set titleold=xterm
"    because vim can't restore the old title
set viminfo='50,\"1000,n~/.viminfo
"    so we remember things between processes
set nohlsearch
"    we don't want no highlighting of search results
set keywordprg=man
"    keywordprg:  Program to use for the "K" command.
"set cindent
"    C-style automatic indenting
"
set grepprg=ack\ --nocolor\ --nogroup\ '$*'\ *\ /dev/null
"
"set grepprg=grep\ -Prn\ --exclude-from=$HOME/.grepignore\ '$*'\ *\ /dev/null
"   GNU grep 2.5 (requires pcre for -P), use with :grep, :cn, :cp, :cl
"
set terse
"    because we prefer terse error messages
set writeany autowrite
"    because we want to write out our file whenever we can,
"    like on a :tag, :stop, or :next
set tabstop=4
"    so tabs look right for us
set shiftwidth=4
"    so tabstops look right for us
set expandtab
"       actually, I don't like tabs. Everyone has different settings so
"       tabbed indents look different everywhere.
set report=1
"    so we are told whenever we affect more than 1 line
set autoindent
"    so i don't have to tab in
set redraw optimize
"    keep the screen tidy
set autowrite
"    automatically save modifications to files when you use critical
"    (external) commands
set noerrorbells
"    damn beeps
set noignorecase
"    don't ignore case in search patterns
set showmatch
"    show matching paren for last ')'
set showmode
"    show current mode
set path=.,/usr/include,/usr/local/include,/sw/include,,
"   so you can "gf" on #include statements
set ruler
"    show cursor position
filetype on
"    process filetype-specific autocommands
set tags+=$PTAGSFILE
"       perl tags generated by ptags and the projptags bash function
set complete+=k~/.vimcomplete
"
set backupdir=~/tmp/vim
set backup
"
set pastetoggle=<C-k><C-a>
"
syntax enable
colorscheme darkblue
"
if &term == "xterm"
    " set t_kb=<C-h>
    fixdel
endif

" :`x,`ys/a/b/g
"       replace in range marked by markers x and y
"
"    INPUT MACROS that i always want active
"
imap <C-z> <Esc>:stop<CR>
"    so i can stop in input mode.
"
imap <C-o> <Esc>O
"    lets me do kindof a negative carriage return in input mode.
"
"    EXCHANGE MACROS -- for exchanging things
"
nmap v xp
"    exchange current char with next one in edit mode
nmap V :m+1<CR>
"    exchange current line with next one in edit mode
imap <C-p> <Esc>hxpa
"    exchange last typed char with penultimate one in insert mode
" nmap = <C-^>
"    edit previously edited file
map -- mpgg=G'p
"    reindent whole file (uses 'p' buffer)
"
imap <C-F> <Esc>gUiw`]a
"       make the word before the cursor uppercase. Handy to type words in
"       lowercase and then make them uppercase.
"
nmap ,f gUiw
"       uppercase the word under the cursor
"
nmap <C-_> :w<CR>
imap <C-_> <Esc><C-_>
"    write out the file
"
nmap \| i<CR><Esc>
"    split line
"
nmap Y y$
"    so Y is analagous to C and D
"
nmap <C-p> :prev<CR>
"   go to previous file in list
"
nmap <C-n> :n<CR>
"   go to next file in list
"
" browsing through :grep results (and through errors)
nmap <C-v><C-n> :cnext<CR>
imap <C-v><C-n> <Esc><C-v><C-n>
nmap <C-v><C-p> :cprev<CR>
imap <C-v><C-p> <Esc><C-v><C-p>
"
" browsing through tags
nmap <C-k><C-n> :tnext<CR>
imap <C-k><C-n> <Esc><C-k><C-p>
nmap <C-k><C-p> :tprev<CR>
imap <C-k><C-p> <Esc><C-k><C-p>
"
" ,Sl = "squeeze lines" - turns a block of empty lines into *one* empty line
nmap ,Sl :g/^[<C-I> ]*$/,/[^<C-I> ]/-j<C-M>
"
nmap ,@ <Esc>"mdd@m
"    xqt line as a straight vi command (buffer m, use @@ to repeat)
nmap ,! 0i:r!<Esc>"ndd@n
"    xqt line as :r! command (buffer n, use @@ to repeat)
nmap ,: "yyy:@y<CR>
"    xqt line as ex command (buffer y, use @@ to repeat)
"
nmap ,t :!pod2text % \| less<CR><CR>
"    displays the current file's POD as text (for testing)
"
nmap ,C :!podchecker %<CR>
"
nmap ,y :%!perltidy -ole=unix -st -se -bar -ce -vt=2 -pt=2 -bbs -bbc -bbb -sob<CR>
"
nmap _# :.perldo s/^(\s*)(?!#)/$1# /<CR>
"    from edit mode, this comments a line
"
nmap _- :.perldo s/^(\s*)# /$1/<CR>
"    and this undoes it
"
nmap ,# :?^$?+1,/^$/-1perldo s/^(\s*)(?!#)/$1# /<CR>
"    comments all lines in the current block as delimited by empty lines
"
nmap ,- :?^$?+1,/^$/-1perldo s/^(\s*)# /$1/<CR>
"    undo block comment
"
nmap ,c :make<CR>
"       Check current Perl program for syntactic correctness
"
" deprecated, use 'K'
"nmap <C-k><C-d> :exec "!perlinfo ".expand("<cword>")<CR>
"imap <C-k><C-d> <Esc><C-k><C-d>
"       look up any keyword
"
nmap <C-k><C-i> ?^package <CR>w:exec ":tag __SUBCLASS__".expand("<cword>")<CR>
imap <C-k><C-i> <Esc><C-k><C-i>
"       jump to subclasses, use :tp and :tn to navigate
"
nmap <C-k><C-t> ?^package <CR>w:exec ":tag __TEST__".expand("<cword>")<CR>
imap <C-k><C-t> <Esc><C-k><C-t>
"       jump to partner class (test <-> normal, see ptags program)
"
"nmap <C-k><C-u> ?^package <CR>w:exec expand("!perl $PROJROOT/t/00test_classes.t --exact <cword>")<CR>
"imap <C-k><C-u> <Esc><C-k><C-u>
"       run unit tests for the current class (and other classes containing the name)
"
"nmap <C-k><C-b> :let mylastpat=@/<CR>/^use\s\+base<CR>/[A-Z]<CR>:exec ":tag ".expand("<cword>")<CR>:let @/=mylastpat<CR>
nmap <C-k><C-b> ?^package <CR>w:exec ":tag __SUPER__".expand("<cword>")<CR>
imap <C-k><C-b> <Esc><C-k><C-b>
"       jump to base class
"
imap <C-k><C-o> <Esc><C-k><C-o>
"       support for autocommands that switch between pm and pod, see
"       BufEnter commands below. With this, they also work in insert mode.
"
nmap ,v :e ~/.vimrc<CR>
"       edit .vimrc (this file)
nmap ,u :source ~/.vimrc<CR>
"       update by reading this file
"
nmap ,q :%!perl -MMIME::QuotedPrint -e'local$/;print decode_qp(<>)'<CR>
"       decode quoted-printable mail
"
nmap ,e :%!expand -4<CR>
"    expand tabs to 4 stops
"
nmap <CR> o<Esc>
"    quick insertion of a newline
"
ab qtop #!/usr/bin/env perl<CR><BS><CR>use warnings;<CR>use strict;<CR>
ab qopen open my $fh, $file or die "can't open $file: $!\n";<CR>close $fh or die "can't close $file: $!\n";
ab qudd use Data::Dumper; warn Dumper
ab qsep # ====================================================================
"
nmap ,mm :%s/<C-v><CR>$/<CR>
"    remove moronic Windows line endings
"
"
"       AUTOCOMMANDS
"
"function! ASR_approved()
"    if (match(getline(1),"Newsgroups: alt.sysadmin.recovery")!= -1)
"        exe "/^$/-1r!echo 'Approved: as if'"
"    endif
"endfunction
"

function! YAMLTestMappings()
    noremap <buffer> ,t :!regprove.pl %:p<CR>
endfunction

"
"       prevent sourcing autocommands more than once
"
if !exists("autocommands_loaded")
    let autocommands_loaded = 1

" autocmd VimEnter    *         :perl use Vi;
" autocmd BufRead .followup     call ASR_approved()

" When editing a file, always jump to the last known cursor position.
" Don't do it when the position is invalid.

  autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif

" editing mail via mutt:
" remove the quoted signature, also positions cursor after quoted text
" autocmd BufReadPost /tmp/mutt* :g/^> -- $/.;/^$/-d

  autocmd FileType make      set noexpandtab shiftwidth=8
  autocmd Filetype perl      call Filetype_Perl()
  autocmd BufEnter    *.pod  call Filetype_Perl()
  autocmd BufEnter    *.t    call Filetype_Perl()

  autocmd FileType yaml      call YAMLTestMappings()

  autocmd BufNewFile  *.txt  set noai
  autocmd BufLeave    *.txt  set ai

  " switch between .pm and .pod file
  autocmd BufEnter    *.pm   nmap <C-k><C-o> :e %:r.pod<CR>
  autocmd BufEnter    *.pod  nmap <C-k><C-o> :e %:r.pm<CR>

  autocmd BufEnter    * doautocmd FileType

  autocmd Filetype * let x = 1
" so that filetype functions are re-called when switching buffers.
" necessary because when switching back and forth between regular files
" and :help files, the comment settings would get messed up
" and the second FileType is so that switching files doesn't complain when
" there aren't any autocommands
endif
"
" toggle display of linenumbers; when on also don't mix wrapped lines
" and linenumbers
let line_number_mode = 0
fun! ToggleNumbers()
    if g:line_number_mode == 0
        let g:line_number_mode = 1
        set number
        set showbreak=\ \ \ \ \ \ \ \
    else
        let g:line_number_mode = 0
        set nonumber
        set showbreak=
    endif
endfunction
nmap ,1 :call ToggleNumbers()<CR>
"
"
" toggle encoding between latin1 and utf-8. Useful when entering japanese
" characters while in latin1, but viewing them while in utf-8.
let myencoding = "latin1"
fun! ToggleEncoding()
    if &encoding == "latin1"
        set encoding=utf-8
    else
        set encoding=latin1
    endif
endfunction
nmap <C-k><C-e> :call ToggleEncoding()<CR>
imap <C-k><C-e> <Esc><C-k><C-e>
"
nmap ,X :silent execute "!chmod a+x %"<CR>
nmap ,x :silent execute "!chmod a-x %"<CR>
"   turn executable bit on and off

function! Filetype_Perl()
  if exists("b:did_ftplugin") | return | endif
  let b:did_ftplugin = 1

  setlocal textwidth=78
  setlocal expandtab
  setlocal tabstop=4
  setlocal shiftwidth=4
  setlocal cindent
  setlocal cinkeys=0{,0},0),:,!^F,o,O,e
  " set smartindent

  " Set formatoptions to break comment lines but not other lines,
  " and insert the comment leader when hitting <CR> or using "o".
  " Also you can do "gq}" on a comment to format until the end
  " of the paragraph.

  setlocal fo-=t fo+=croql
  setlocal comments=:#
  setlocal define=[^A-Za-z_]

  setlocal iskeyword=48-57,_,A-Z,a-z,:
  setlocal keywordprg=perlinfo

  setlocal filetype=perl

  " setlocal makeprg=perl\ -Mstrict\ -wc\ %
  " setlocal errorformat+=%m\ at\ %f\ line\ %l

  setlocal makeprg=$VIMRUNTIME/tools/efm_perl.pl\ -c\ %\ $*
  setlocal errorformat=%f:%l:%m

  " Set this once, globally
  " if !exists("perlpath")
  "   if &shellxquote != '"'
  "     let perlpath = system('perl -e "print join(q/,/,@INC)"')
  "   else
  "     let perlpath = system("perl -e 'print join(q/,/,@INC)'")
  "   endif
  "   let perlpath = substitute(perlpath, ',.$',',,','')
  " endif
  " let &l:path=perlpath
endfunction


fun! UsePackage()
    let default = expand("<cword>")
    call inputsave()
    let module = input("Module (default " . default . "): ")
    call inputrestore()
    if module == ""
        let module = default
    endif
    normal mz
    normal G$
    call search("^use ", "b")
    call append(line("."), "use " . module . ";")
    normal `z
endfunction
nmap <C-k><C-u> :call UsePackage()<CR>
imap <C-k><C-u> <Esc><C-k><C-u>a
